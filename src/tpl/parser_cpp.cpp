/*
**	parser.cpp
**
**	This file was generated by the RedStar Pegasus compiler tool (v5.00).
**
**	RedStar Pegasus is a trademark of RedStar Technologies.
**	Copyright (c) 2006-2014, RedStar Technologies, All rights reserved.
*/

#ifndef PARSER_$0
#define PARSER_$0

#include <stdio.h>
#include <stdlib.h>

namespace $0
{
	/**
	**	Implementation of the parser. Its responsibility is to obtain tokens from a scanner, verify proper syntax
	**	of all input and execute the appropriate actions.
	*/

	class Parser
	{
		protected:

		/**
		**	Parser stack.
		*/
		int *stack, stackSize;

		/**
		**	Value list.
		*/
		void **argv;

		public:

		/**
		**	Initializes the parser context.
		*/
		Parser (int stackSize=1024)
		{
			this->stack = new int[stackSize];
			this->stackSize = stackSize;

			this->argv = new void*[128];
		}

		/**
		**	Releases all allocated data and resources.
		*/
		~Parser ()
		{
			delete this->stack;
			delete this->argv;
		}

		/**
		**	Parses data from the specified scanner and returns the final parsed object.
		*/
		$T parse (Scanner *scanner, Context *context = nullptr)
		{
			int error=0, state=1, reduce=0, shift=1, symbol=-1;
			int nonterm, rule, release, shifted, bp=0;

			int *stack = this->stack, sp = 0;
			void *temp, **argv = this->argv;

			Token *token = nullptr;

			if (context == nullptr)
				context = new Context ();

			while (1)
			{
				if (error)
				{
					printf ("(Parser Error)\n");

					for (int i = 1; i <= sp; i++)
						printf (">> %u\n", stack[i]);

					argv[0] = nullptr;
					break;
				}

				if (shift)
				{
					if (token != nullptr)
						argv[bp++] = token;

					token = scanner->shiftToken();
					symbol = token->getType();
					shift = 0;
				}

				if (reduce)
				{
					if (nonterm == 0)
						break;

					state = stack[sp -= release];
					bp -= shifted - 1;
				}
				else
				{
					if (sp == stackSize-1) { printf ("(Stack Overflow)\n"); error = 1; continue; }
					stack[++sp] = state;
				}

				$1
			}

			if (token != nullptr) delete token;

			return $R;
		};

		/**
		**	Parses data from the specified file and returns the final parsed object. An scanner will be automatically created.
		*/
		$T parse (const char *filename, Context *context = nullptr)
		{
			IDataProvider *input = new FileDataProvider (filename);
			Scanner *scanner = new Scanner (input);

			$T value = parse (scanner, context);

			delete scanner;
			delete input;

			return value;
		}

		/**
		**	Parses data from the specified file and returns the final parsed object. A new parser and scanner will be
		**	automatically created and released by using this method.
		*/
		static $T parseFile (const char *filename, Context *context = nullptr)
		{
			Parser *parser = new Parser ();

			$T value = parser->parse (filename, context);
			delete parser;

			return value;
		}
	};
};

#endif
