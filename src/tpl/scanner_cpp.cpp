/*
**	scanner.cpp
**
**	This file was generated by the RedStar Pegasus compiler tool (v5.00).
**
**	RedStar Pegasus is a trademark of RedStar Technologies.
**	Copyright (c) 2006-2014, RedStar Technologies, All rights reserved.
*/

#ifndef SCANNER_$0
#define SCANNER_$0

#include <stdio.h>
#include <string.h>

namespace $0
{
	/**
	**	Standard file-source data provider for the scanner.
	*/
	class IDataProvider
	{
		public:

		/**
		**	Returns the name of the data provider.
		*/
		virtual const char *getName (void) = 0;

		/**
		**	Reads a byte from the data source and returns it. A minus-one (-1) will be returned on EOF.
		*/
		virtual int getByte (void) = 0;
	};


	/**
	**	Standard file-source data provider for the scanner.
	*/
	class FileDataProvider : public IDataProvider
	{
		protected:

		/**
		**	Name of the file from which data is read.
		*/
		const char *filename;

		/**
		**	File handle.
		*/
		FILE *fp;

		public:

		/**
		**	Initializes the data provider to read data from the specified file.
		*/
		FileDataProvider (const char *filename)
		{
			this->filename = filename;
			this->fp = fopen (filename, "rb");
		}

		/**
		**	Closes the file related to the provider.
		*/
		~FileDataProvider ()
		{
			if (this->fp != nullptr)
			{
				fclose (this->fp);
				this->fp = nullptr;
			}
		}

		/**
		**	Returns the name of the data provider.
		*/
		virtual const char *getName (void)
		{
			return this->filename;
		}

		/**
		**	Reads a byte from the data source and returns it. A minus-one (-1) will be returned on EOF.
		*/
		virtual int getByte (void)
		{
			return this->fp == nullptr ? -1 : getc (this->fp);
		}
	};


	/**
	**	Describes a token, that is a string obtained from a data source that belongs to a certain group which gives it meaning.
	*/
	class Token
	{
		protected:

		/**
		**	String value of the token.
		*/
		char *value;

		/**
		**	Length of the token's value.
		*/
		int length;

		/**
		**	Type of the token.
		*/
		int type;

		/**
		**	Name of the data source of the token.
		*/
		const char *source;

		/**
		**	Line number and column number where the token appears in the data source.
		*/
		unsigned line, col;

		public:

		/**
		**	Initializes the token object with the specified parameters.
		*/
		Token (const char *source, char *value, int length, int type, int line, int col)
		{
			this->value = (char *)new char[length+1];
			this->length = length;
			this->type = type;

			this->source = source;
			this->line = line;
			this->col = col;

			memcpy (this->value, value, length);
			this->value[length] = '\0';
		}

		/**
		**	Destroys the token instance.
		*/
		virtual ~Token ()
		{
			if (this->value != nullptr)
				delete this->value;
		}

		/**
		**	Changes the type of the token.
		*/
		Token *setType (int type)
		{
			this->type = type;
			return this;
		}

		/**
		**	Compares two tokens and returns true if both are equal.
		*/
		bool equals (Token *item)
		{
			if (item == nullptr || item->type != type || item->length != length)
				return false;

			return !memcmp (item->value, value, length);
		}

		/**
		**	Compares the token value against the given parameter and returns true if they match.
		*/
		bool equals (char *value)
		{
			if (value == nullptr || (int)strlen(value) != length)
				return false;

			return !memcmp (this->value, value, length);
		}

		/**
		**	Compares the token type (and optionally the value too) against the provided arguments.
		*/
		bool equals (int type, char *value=nullptr)
		{
			if (this->type != type || (value != nullptr && (int)strlen(value) != this->length))
				return false;

			return value == nullptr ? true : !memcmp (this->value, value, length);
		}

		/**
		**	Returns the string value of the token. If the clear parameter is set to true the underlying string will
		**	not be released upon destruction of the token.
		*/
		char *getValue (bool clear=false)
		{
			char *value = this->value;

			if (clear)
				this->value = nullptr;

			return value;
		}

		/**
		**	Returns the string value of the token and removes the internal reference to it to prevent deallocation. By default
		**	the object is destroyed afterwards but that can be prevented by setting the destroy flag to false.
		*/
		char *acquireValue (bool destroy=true)
		{
			char *value = this->value;
			this->value = nullptr;

			if (destroy)
				delete this;

			return value;
		}

		/**
		**	Returns the length of the value of the token.
		*/
		int getLength ()
		{
			return this->length;
		}

		/**
		**	Returns the value of the token as a character.
		*/
		int getChar ()
		{
			return this->value[0];
		}

		/**
		**	Returns the token type.
		*/
		int getType ()
		{
			return this->type;
		}

		/**
		**	Returns the source name.
		*/
		const char *getSource ()
		{
			return this->source;
		}

		/**
		**	Returns the column number where the token appears in the source.
		*/
		int getCol ()
		{
			return this->col;
		}

		/**
		**	Returns the line number where the token appears in the source.
		*/
		int getLine ()
		{
			return this->line;
		}
	};


	/**
	**	Implementation of the input scanner. Its responsibility is to scan symbols from an input stream.
	*/
	class Scanner
	{
		protected:

		/**
		**	Input data provider.
		*/
		IDataProvider *input;

		/**
		**	Token queue. The shiftToken() method removes and returns the top element on this queue. You can use
		**	the peekToken(i) method to just read some token at the ith position after the top element.
		*/
		List<Token*> *queue;

		/**
		**	Scanner context details.
		*/
		int state, shift, symbol, linenum, colnum;

		/**
		**	Scanner stack.
		*/
		int *stack, sp, stackSize;

		/**
		**	Buffer for the last token parsed.
		*/
		char *value;

		public:

		/**
		**	Initializes the scanner context.
		*/
		Scanner (IDataProvider *input, int stackSize=1024)
		{
			this->input = input;

			this->state = 1;
			this->shift = 1;
			this->symbol = -1;

			this->linenum = 1;
			this->colnum = 1;

			this->stack = new int[stackSize];
			this->stackSize = stackSize;
			this->sp = 0;

			*(this->value = new char[1024]) = '\0';

			this->queue = new List<Token*> ();
		}

		/**
		**	Releases all allocated data and resources.
		*/
		~Scanner ()
		{
			delete this->queue->clear();

			delete this->stack;
			delete this->value;
		}

		/**
		**	Removes and returns the top token on the token queue.
		*/
		Token *shiftToken ()
		{
			if (this->queue->count == 0)
			{
				parseToken();
			}

			return this->queue->shift();
		}

		/**
		**	Returns the token at the ith-position from the top of the queue.
		*/
		Token *peekToken (int i)
		{
			while (this->queue->count <= i)
			{
				parseToken();
			}

			Linkable<Token*> *im = this->queue->top;

			while (i-- && im != nullptr)
			{
				im = im->next;
			}

			return im ? im->value : nullptr;
		}

		/**
		**	Adds a token at the top of the token queue.
		*/
		Scanner *unshiftToken (Token *token)
		{
			this->queue->unshift (token);
			return this;
		}

		/**
		**	Translates a token to an array-token if the token code matches the array composition code.
		*/
		protected: Token *translate (Token *token)
		{
$E
		}

		/**
		**	Scans the next symbol and returns a boolean indicating if a symbol was found or not. The newly obtained
		**	token is added to the token queue. When this function returns false a type -1 (EOF) token will be added.
		*/
		public: bool parseToken ()
		{
			int error=0, reduce=0, state=this->state, shift=this->shift;
			int nonterm, release, code, symbol=this->symbol;
			int _colnum=this->colnum, _linenum=this->linenum;

			int *stack = this->stack, sp = this->sp;
			char *bp = this->value;

			while (1)
			{
				if (error)
				{
					printf ("error");
					break;
				}

				if (shift)
				{
					if (symbol != -1)
					{
						*bp++ = symbol;

						colnum++;

						if (symbol == '\n')
						{
							colnum = 1;
							linenum++;
						}
					}

					symbol = input->getByte();
					shift = 0;
				}

				if (reduce)
				{
					if (nonterm == 0)
						break;

					state = stack[sp -= release];

					if (reduce == 2)
					{
						this->sp = sp;
						this->state = state;
						this->shift = shift;
						this->symbol = symbol;

						*bp = '\0';
					}

					if (reduce == 3)
					{
						_linenum = linenum;
						_colnum = colnum;

						bp = this->value;
					}

					if (reduce == 2)
					{
						this->queue->push (translate (new Token (input->getName(), this->value, (int)(bp - this->value), code, _linenum, _colnum)));
						return true;
					}
				}
				else
				{
					if (sp == stackSize-1) { printf ("stack overflow"); error = 1; continue; }
					stack[++sp] = state;
				}

$1
			}

			this->queue->push (new Token (input->getName(), "", 0, -1, _linenum, _colnum));
			return false;
		}
	};
};

#endif
