/*
**	This file was generated by the RedStar Pegasus compiler tool (v5.00).
**	RedStar Pegasus is a trademark of RedStar Technologies.
**	Copyright (c) 2006-2014, RedStar Technologies, All rights reserved.
*/

#ifndef __scanner_asx_h
#define __scanner_asx_h

#include <asr/utils/List>
#include <asr/utils/Linkable>

#include <stdio.h>
#include <string.h>

namespace asx
{
	using asr::utils::List;
	using asr::utils::Linkable;

	/**
	 * @brief Data provider interface.
	 */
	class IDataProvider
	{
		public:

		/**
		 * @brief Returns the name of the data provider.
		 * @return const char* 
		 */
		virtual const char *getName (void) = 0;

		/**
		 * @brief Reads a byte from the data source and returns it. A -1 will be returned on EOF.
		 * @return int 
		 */
		virtual int getByte (void) = 0;
	};

	/**
	 * @brief File data provider.
	 */
	class FileDataProvider : public IDataProvider
	{
		protected:

		/**
		 * @brief Name of the file from which data is read.
		 */
		const char *filename;

		/**
		 * @brief File stream handle.
		 */
		FILE *fp;

		public:

		/**
		 * @brief Initializes the data provider to read data from the specified file.
		 * @param filename 
		 */
		FileDataProvider (const char *filename)
		{
			this->filename = filename;
			this->fp = fopen(filename, "rb");
		}

		/**
		 * @brief Closes the underlying file stream.
		 */
		~FileDataProvider ()
		{
			if (this->fp != nullptr)
			{
				fclose (this->fp);
				this->fp = nullptr;
			}
		}

		/**
		 * @brief Returns the name of the data provider.
		 * @return const char* 
		 */
		virtual const char *getName (void)
		{
			return this->filename;
		}

		/**
		 * @brief Reads a byte from the data source and returns it. A -1 will be returned on EOF.
		 * @return int 
		 */
		virtual int getByte (void)
		{
			return this->fp == nullptr ? -1 : getc (this->fp);
		}
	};

	/**
	 * @brief Describes a token, that is a string obtained from a data source that belongs to a certain token group which gives it meaning.
	 */
	class Token
	{
		protected:

const int keyword = 256;
const int identifier = 257;
const int number = 258;
const int symbol = 259;


		/**
		 * @brief String value of the token.
		 */
		char *value;

		/**
		 * @brief Length of the token's value.
		 */
		int length;

		/**
		 * @brief Type of the token.
		 */
		int type;

		/**
		 * @brief Name of the data source of the token.
		 */
		const char *source;

		/**
		 * @brief Line number.
		 */
		unsigned line;

		/**
		 * @brief Column number.
		 */
		unsigned col;

		public:

		/**
		 * @brief Initializes the token object with the specified parameters.
		 * 
		 * @param source Data source name.
		 * @param value Token value.
		 * @param length Length.
		 * @param type Token type.
		 * @param line Line number.
		 * @param col Column number.
		 */
		Token (const char *source, const char *value, int length, int type, int line, int col)
		{
			this->value = (char *)new char[length+1];
			this->length = length;
			this->type = type;

			this->source = source;
			this->line = line;
			this->col = col;

			memcpy (this->value, value, length);
			this->value[length] = '\0';
		}

		/**
		 * @brief Destroys the token and its related value. To prevent value from being deleted use `getValue(true)` or `acquireValue`.
		 */
		virtual ~Token ()
		{
			if (this->value != nullptr)
				delete this->value;
		}

		/**
		 * @brief Changes the type of the token.
		 * @param type 
		 * @return Token* 
		 */
		Token *setType (int type)
		{
			this->type = type;
			return this;
		}

		/**
		 * @brief Compares two tokens and returns true if both are equal.
		 * @param token 
		 * @return bool 
		 */
		bool equals (Token *token) const
		{
			if (token == nullptr || token->type != type || token->length != length)
				return false;

			return !memcmp (token->value, value, length);
		}

		/**
		 * @brief Compares the token value against the given string and returns true if they match.
		 * @param value 
		 * @return bool 
		 */
		bool equals (const char *value) const
		{
			if (value == nullptr || (int)strlen(value) != length)
				return false;

			return !memcmp (this->value, value, length);
		}

		/**
		 * @brief Compares the token type (and optionally the value as well) against the provided arguments.
		 * @param type 
		 * @param value 
		 * @return bool 
		 */
		bool equals (int type, char *value=nullptr) const
		{
			if (this->type != type || (value != nullptr && (int)strlen(value) != this->length))
				return false;

			return value == nullptr ? true : !memcmp (this->value, value, length);
		}

		/**
		 * @brief Returns the string value of the token. If the `preserve` parameter is set to `true` the underlying string will
		 * not be deleted upon destruction of the token.
		 * 
		 * @param preserve 
		 * @return char* 
		 */
		char *getValue (bool preserve=false)
		{
			char *value = this->value;

			if (preserve)
				this->value = nullptr;

			return value;
		}

		/**
		 * @brief Returns the string value of the token and removes the internal reference to it to prevent deallocation. By default
		 * the object is destroyed afterwards but that can be prevented by setting the `selfDestruct` parameter to `false`.
		 * 
		 * @param selfDestruct 
		 * @return char* 
		 */
		char *acquireValue (bool selfDestruct=true)
		{
			char *value = this->value;
			this->value = nullptr;

			if (selfDestruct)
				delete this;

			return value;
		}

		/**
		 * @brief Returns the length of the value of the token.
		 * @return int 
		 */
		int getLength() const {
			return this->length;
		}

		/**
		 * @brief Returns the value of the token as a character (first char of the token value).
		 * @return int 
		 */
		int getChar() const {
			return this->value[0];
		}

		/**
		 * @brief Returns the token type.
		 * @return int 
		 */
		int getType() const {
			return this->type;
		}

		/**
		 * @brief Returns the source name.
		 * @return const char* 
		 */
		const char *getSource() const {
			return this->source;
		}

		/**
		 * @brief Returns the column number where the token appears in the source.
		 * @return int 
		 */
		int getCol() const {
			return this->col;
		}

		/**
		 * @brief Returns the line number where the token appears in the source.
		 * @return int 
		 */
		int getLine() const {
			return this->line;
		}
	};


	/**
	 * @brief Implementation of the input scanner. Its responsibility is to scan symbols from an input stream.
	 */
	class Scanner
	{
		protected:

		/**
		 * @brief Input data provider.
		 */
		IDataProvider *input;

		/**
		 * @brief Token queue. The `shiftToken` method removes and returns the top element on this queue. You can use
		 * the `peekToken` method to just read (without removing) some token at an i-th position after the top element.
		 */
		List<Token*> *queue;

		/**
		 * @brief Scanner context details.
		 */
		int state, shift, symbol, linenum, colnum;

		/**
		 * @brief Scanner stack.
		 */
		int *stack, sp, stackSize;

		/**
		 * @brief Buffer for the last token parsed.
		 */
		char *value;

		public:

		/**
		 * @brief Initializes the scanner context.
		 * @param input Data provider.
		 * @param stackSize Scanner stack size (default is 1024).
		 */
		Scanner (IDataProvider *input, int stackSize=1024)
		{
			this->input = input;

			this->state = 1;
			this->shift = 1;
			this->symbol = -1;

			this->linenum = 1;
			this->colnum = 1;

			this->stack = new int[stackSize];
			this->stackSize = stackSize;
			this->sp = 0;

			*(this->value = new char[1024]) = '\0';
			this->queue = new List<Token*> ();
		}

		/**
		 * @brief Releases all allocated data and resources.
		 */
		~Scanner ()
		{
			delete this->queue->clear();
			delete this->stack;
			delete this->value;
		}

		/**
		 * @brief Removes and returns the token at the top of the token queue.
		 * @return Token* 
		 */
		Token *shiftToken ()
		{
			if (this->queue->length() == 0)
				parseToken();

			return this->queue->shift();
		}

		/**
		 * @brief Returns the token at the ith-position from the top of the queue.
		 * @param i 
		 * @return Token* 
		 */
		Token *peekToken (int i)
		{
			while (this->queue->length() <= i)
				parseToken();

			Linkable<Token*> *im = this->queue->head();

			while (i-- > 0 && im != nullptr)
				im = im->next();

			return im ? im->value : nullptr;
		}

		/**
		 * @brief Adds a token to the top of the token queue.
		 * @param token 
		 * @return Scanner* 
		 */
		Scanner *unshiftToken (Token *token)
		{
			this->queue->unshift(token);
			return this;
		}

		/**
		 * @brief Translates a token to an array-token if the token code matches the array composition code. VIOLET
		 */
		protected: Token *translate (Token *token)
		{
            if (token->getType() == 257)
            {
                if (token->equals("var")) { return token->setType(256); }
                if (token->equals("all")) { return token->setType(256); }
            }

            return token;
		}

		/**
		 * @brief Scans the next symbol and returns a boolean indicating if a symbol was found or not. The newly obtained
		 * token will be added to the token queue. When this function returns `false` a type -1 (EOF) token will be added.
		 */
		public: bool parseToken ()
		{
			int error=0, reduce=0, state=this->state, shift=this->shift;
			int nonterm, release, code, symbol=this->symbol;
			int _colnum=this->colnum, _linenum=this->linenum;

			int *stack = this->stack, sp = this->sp;
			char *bp = this->value;

			while (1)
			{
				if (error)
				{
					printf ("error");
					break;
				}

				if (shift)
				{
					if (symbol != -1)
					{
						*bp++ = symbol;

						colnum++;

						if (symbol == '\n')
						{
							colnum = 1;
							linenum++;
						}
					}

					symbol = input->getByte();
					shift = 0;
				}

				if (reduce)
				{
					if (nonterm == 0)
						break;

					state = stack[sp -= release];

					if (reduce == 2)
					{
						this->sp = sp;
						this->state = state;
						this->shift = shift;
						this->symbol = symbol;

						*bp = '\0';
					}

					if (reduce == 3)
					{
						_linenum = linenum;
						_colnum = colnum;

						bp = this->value;
					}

					if (reduce == 2)
					{
						this->queue->push (translate (new Token (input->getName(), this->value, (int)(bp - this->value), code, _linenum, _colnum)));
						return true;
					}
				}
				else
				{
					if (sp == stackSize-1) { printf ("stack overflow"); error = 1; continue; }
					stack[++sp] = state;
				}

switch (state)
{
    case 1:
        if (reduce)
        {
            switch (nonterm)
            {
                case 7: state = 2; break;
                case 1: state = 4; break;
                case 3: state = 5; break;
                case 5: state = 6; break;
                case 4: state = 7; break;
                case 2: state = 8; break;
            }

            reduce = 0;
            break;
        }

        switch (symbol)
        {
            case -1: state = 3; shift = 1; break;
            case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 95: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: state = 9; shift = 1; break;
            case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: state = 10; shift = 1; break;
            case 59: case 61: state = 11; shift = 1; break;
            case 9: case 10: case 13: case 32: state = 12; shift = 1; break;
        }

        if (!shift) error = 1;
        break;

    case 2:
        if (reduce)
        {
            switch (nonterm)
            {
                case 1: state = 14; break;
                case 3: state = 5; break;
                case 5: state = 6; break;
                case 4: state = 7; break;
                case 2: state = 8; break;
            }

            reduce = 0;
            break;
        }

        switch (symbol)
        {
            case -1: state = 13; shift = 1; break;
            case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 95: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: state = 9; shift = 1; break;
            case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: state = 10; shift = 1; break;
            case 59: case 61: state = 11; shift = 1; break;
            case 9: case 10: case 13: case 32: state = 12; shift = 1; break;
        }

        if (!shift) error = 1;
        break;

    case 3:
        nonterm = 0; release = 1; reduce = 1;
        break;

    case 4:
        nonterm = 7; release = 1; reduce = 1;
        break;

    case 5:
        switch (symbol)
        {
            case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 95: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: state = 15; shift = 1; break;
        }

        if (shift) break;

        nonterm = 1; release = 1; reduce = 2; code = 257;
        break;

    case 6:
        switch (symbol)
        {
            case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: state = 16; shift = 1; break;
        }

        if (shift) break;

        nonterm = 1; release = 1; reduce = 2; code = 258;
        break;

    case 7:
        nonterm = 1; release = 1; reduce = 2; code = 259;
        break;

    case 8:
        nonterm = 1; release = 1; reduce = 3;
        break;

    case 9:
        nonterm = 3; release = 1; reduce = 1;
        break;

    case 10:
        nonterm = 5; release = 1; reduce = 1;
        break;

    case 11:
        nonterm = 4; release = 1; reduce = 1;
        break;

    case 12:
        nonterm = 2; release = 1; reduce = 1;
        break;

    case 13:
        nonterm = 0; release = 2; reduce = 1;
        break;

    case 14:
        nonterm = 7; release = 2; reduce = 1;
        break;

    case 15:
        nonterm = 3; release = 2; reduce = 1;
        break;

    case 16:
        nonterm = 5; release = 2; reduce = 1;
        break;
}
			}

			this->queue->push (new Token (input->getName(), "", 0, -1, _linenum, _colnum));
			return false;
		}
	};
};

#endif
