/*
**	This file was generated by the RedStar Pegasus tool.
*/

#ifndef __parser_asx_h
#define __parser_asx_h

#include <stdio.h>
#include <stdlib.h>

namespace asx
{
	/**
	 * @brief Source parser.
	 */
	class Parser
	{
		protected:

		/**
		 * @brief Parser stack.
		 * 
		 */
		int *stack, stackSize;

		/**
		 * @brief Current production rule values.
		 */
		void **argv;

		public:

		/**
		 * @brief Initializes the parser context.
		 * @param stackSize Parser stack size (default: 1024).
		 */
		Parser (int stackSize=1024)
		{
			this->stack = new int[stackSize];
			this->stackSize = stackSize;

			this->argv = new void*[128];
		}

		/**
		 * @brief Releases resources.
		 */
		~Parser()
		{
			delete this->stack;
			delete this->argv;
		}

		/**
		 * @brief Parses data from the specified scanner and returns the parsed structure.
		 * @param scanner Scanner to obtain tokens.
		 * @param context Parser context.
		 * @return void *
		 */
		void * parse (Scanner *scanner, Context *context=nullptr)
		{
			int error=0, state=1, reduce=0, shift=1, symbol=-1;
			int nonterm, rule, release, shifted, bp=0;

			int *stack = this->stack, sp = 0;
			void *temp, **argv = this->argv;

			Token *token = nullptr;

			if (context == nullptr)
				context = new Context ();

			while (1)
			{
				if (error)
				{
					printf ("(Parser Error)\n");

					for (int i = 1; i <= sp; i++)
						printf (">> %u\n", stack[i]);

					argv[0] = nullptr;
					break;
				}

				if (shift)
				{
					if (token != nullptr)
						argv[bp++] = token;

					token = scanner->shiftToken();
					symbol = token->getType();
					shift = 0;
				}

				if (reduce)
				{
					if (nonterm == 0)
						break;

					state = stack[sp -= release];
					bp -= shifted - 1;
				}
				else
				{
					if (sp == stackSize-1) { printf ("(Stack Overflow)\n"); error = 1; continue; }
					stack[++sp] = state;
				}

				switch (state)
{
    case 1:
        if (reduce)
        {
            switch (nonterm)
            {
                case 1: state = 2; break;
                case 2: state = 3; break;
            }

            reduce = 0;
            break;
        }

        nonterm = 2; release = 0; reduce = 1; rule = 2; shifted = 0;
        temp = (void *)(nullptr);
        argv[bp-shifted] = temp;
        break;

    case 2:
        switch (symbol)
        {
            case -1: state = 4; shift = 1; break;
        }

        if (!shift) error = 1;
        break;

    case 3:
        if (reduce)
        {
            switch (nonterm)
            {
                case 3: state = 5; break;
                case 4: state = 6; break;
            }

            reduce = 0;
            break;
        }

        if () {
            nonterm = 1; release = 1; reduce = 1; rule = 1; shifted = 1;
            temp = (void *)(nullptr);
            if (argv[bp-1]) delete (void *)argv[bp-1];
            argv[bp-shifted] = temp;
            break;
        }

        switch (symbol)
        {
            case 256: 
                if (token->equals("print")) { state = 7; shift = 1; break; }
                break;
        }

        if (!shift) error = 1;
        break;

    case 4:
        nonterm = 0; release = 2; reduce = 1; rule = 1; shifted = 2;
        temp = (void *)(((void *)argv[bp-2]));
        if (argv[bp-1]) delete (Token *)argv[bp-1];
        argv[bp-shifted] = temp;
        break;

    case 5:
        nonterm = 2; release = 2; reduce = 1; rule = 1; shifted = 2;
        temp = (void *)(nullptr);
        if (argv[bp-2]) delete (void *)argv[bp-2];
        if (argv[bp-1]) delete (void *)argv[bp-1];
        argv[bp-shifted] = temp;
        break;

    case 6:
        nonterm = 3; release = 1; reduce = 1; rule = 1; shifted = 1;
        temp = (void *)(nullptr);
        if (argv[bp-1]) delete (void *)argv[bp-1];
        argv[bp-shifted] = temp;
        break;

    case 7:
        if (reduce)
        {
            switch (nonterm)
            {
                case 5: state = 8; break;
            }

            reduce = 0;
            break;
        }

        switch (symbol)
        {
            case 258: state = 9; shift = 1;
                break;
        }

        if (!shift) error = 1;
        break;

    case 8:
        switch (symbol)
        {
            case 259: 
                if (token->equals(";")) { state = 10; shift = 1; break; }
                break;
        }

        if (!shift) error = 1;
        break;

    case 9:
        nonterm = 5; release = 1; reduce = 1; rule = 1; shifted = 1;
        temp = (void *)(nullptr);
        if (argv[bp-1]) delete (Token *)argv[bp-1];
        argv[bp-shifted] = temp;
        break;

    case 10:
        nonterm = 4; release = 3; reduce = 1; rule = 1; shifted = 3;
        temp = (void *)(printf("!"));
        if (argv[bp-3]) delete (Token *)argv[bp-3];
        if (argv[bp-2]) delete (void *)argv[bp-2];
        if (argv[bp-1]) delete (Token *)argv[bp-1];
        argv[bp-shifted] = temp;
        break;
}
			}

			if (token != nullptr) delete token;

			return (void *)argv[0];
		};

		/**
		 * @brief Parses data from the specified file and returns the parsed structure. An scanner will be automatically created.
		 * @param filepath Path to the source file.
		 * @param context Parser context.
		 * @return void *
		 */
		void * parse (const char *filepath, Context *context=nullptr)
		{
			IDataProvider *input = new FileDataProvider (filepath);
			Scanner *scanner = new Scanner (input);

			void * value = parse (scanner, context);

			delete scanner;
			delete input;

			return value;
		}

		/**
		 * @brief Parses data from the specified file and returns the parser structure. A new parser and scanner will be automatically
		 * created and released when using this method.
		 * 
		 * @param filepath Path to the source file.
		 * @param context Parser context.
		 * @return void * 
		 */
		static void * parseFile (const char *filepath, Context *context=nullptr)
		{
			Parser *parser = new Parser ();

			void * value = parser->parse (filepath, context);
			delete parser;

			return value;
		}
	};
};

#endif
