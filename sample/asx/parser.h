/*
**	parser.cpp
**
**	This file was generated by the RedStar Pegasus compiler tool (v5.00).
**
**	RedStar Pegasus is a trademark of RedStar Technologies.
**	Copyright (c) 2006-2014, RedStar Technologies, All rights reserved.
*/

#ifndef PARSER_asx
#define PARSER_asx

#include <stdio.h>
#include <stdlib.h>

namespace asx
{
	/**
	**	Implementation of the parser. Its responsibility is to obtain tokens from a scanner, verify proper syntax
	**	of all input and execute the sappropriate actions.
	*/

	class Parser
	{
		protected:

		/**
		**	Parser stack.
		*/
		int *stack, stackSize;

		/**
		**	Value list.
		*/
		void **argv;

		public:

		/**
		**	Initializes the parser context.
		*/
		Parser (int stackSize=1024)
		{
			this->stack = new int[stackSize];
			this->stackSize = stackSize;

			this->argv = new void*[128];
		}

		/**
		**	Releases all allocated data and resources.
		*/
		~Parser ()
		{
			delete this->stack;
			delete this->argv;
		}

		/**
		**	Parses data from the specified scanner and returns the final parsed object.
		*/
		void * parse (Scanner *scanner, Context *context = NULL)
		{
			int error=0, state=1, reduce=0, shift=1, symbol=-1;
			int nonterm, rule, release, shifted, bp=0;

			int *stack = this->stack, sp = 0;
			void *temp, **argv = this->argv;

			Token *token = NULL;

			if (context == NULL)
				context = new Context ();

			while (1)
			{
				if (error)
				{
					printf ("(Parser Error)\n");

					for (int i = 1; i <= sp; i++)
						printf (">> %u\n", stack[i]);

					argv[0] = NULL;
					break;
				}

				if (shift)
				{
					if (token != NULL)
						argv[bp++] = token;

					token = scanner->shiftToken();
					symbol = token->getType();
					shift = 0;
				}

				if (reduce)
				{
					if (nonterm == 0)
						break;

					state = stack[sp -= release];
					bp -= shifted - 1;
				}
				else
				{
					if (sp == stackSize-1) { printf ("(Stack Overflow)\n"); error = 1; continue; }
					stack[++sp] = state;
				}

				switch (state)
{
    case 1:
        if (reduce)
        {
            switch (nonterm)
            {
                case 1: state = 2; break;
                case 2: state = 3; break;
            }

            reduce = 0;
            break;
        }

        switch (symbol)
        {
            case 257: 
                if (token->equals("a")) { state = 4; shift = 1; break; }
                break;
        }

        if (shift) break;

        nonterm = 2; release = 0; reduce = 1; rule = 2; shifted = 0;
        nullptr;
        argv[bp-shifted] = nullptr;
        break;

    case 2:
        switch (symbol)
        {
            case -1: state = 5; shift = 1; break;
        }

        if (!shift) error = 1;
        break;

    case 3:
        switch (symbol)
        {
            case 257: 
                if (token->equals("a")) { state = 6; shift = 1; break; }
                break;
        }

        if (!shift) error = 1;
        break;

    case 4:
        nonterm = 2; release = 1; reduce = 1; rule = 1; shifted = 1;
        nullptr;
        if (argv[bp-1]) delete (Token *)argv[bp-1];
        argv[bp-shifted] = nullptr;
        break;

    case 5:
        nonterm = 0; release = 2; reduce = 1; rule = 1; shifted = 2;
        argv[bp-2];
        if (argv[bp-1]) delete (Token *)argv[bp-1];
        argv[bp-shifted] = nullptr;
        break;

    case 6:
        if (reduce)
        {
            switch (nonterm)
            {
                case 3: state = 7; break;
                case 4: state = 8; break;
            }

            reduce = 0;
            break;
        }

        switch (symbol)
        {
            case 257: 
                if (token->equals("x")) { state = 9; shift = 1; break; }
                break;
        }

        if (!shift) error = 1;
        break;

    case 7:
        switch (symbol)
        {
            case 257: 
                if (token->equals("e")) { state = 10; shift = 1; break; }
                break;
        }

        if (!shift) error = 1;
        break;

    case 8:
        switch (symbol)
        {
            case 257: 
                if (token->equals("f")) { state = 11; shift = 1; break; }
                break;
        }

        if (!shift) error = 1;
        break;

    case 9:
        if () {
            nonterm = 3; release = 1; reduce = 1; rule = 1; shifted = 1;
            nullptr;
            if (argv[bp-1]) delete (Token *)argv[bp-1];
            argv[bp-shifted] = nullptr;
            break;
        }

        if () {
            nonterm = 4; release = 1; reduce = 1; rule = 1; shifted = 1;
            nullptr;
            if (argv[bp-1]) delete (Token *)argv[bp-1];
            argv[bp-shifted] = nullptr;
            break;
        }

        break;

    case 10:
        nonterm = 1; release = 4; reduce = 1; rule = 1; shifted = 4;
        nullptr;
        if (argv[bp-3]) delete (Token *)argv[bp-3];
        if (argv[bp-1]) delete (Token *)argv[bp-1];
        argv[bp-shifted] = nullptr;
        break;

    case 11:
        nonterm = 1; release = 4; reduce = 1; rule = 2; shifted = 4;
        nullptr;
        if (argv[bp-3]) delete (Token *)argv[bp-3];
        if (argv[bp-1]) delete (Token *)argv[bp-1];
        argv[bp-shifted] = nullptr;
        break;
}
			}

			if (token != NULL) delete token;

			return (void *)nullptr;
		};

		/**
		**	Parses data from the specified file and returns the final parsed object. An scanner will be automatically created.
		*/
		void * parse (const char *filename, Context *context = NULL)
		{
			IDataProvider *input = new FileDataProvider (filename);
			Scanner *scanner = new Scanner (input);

			void * value = parse (scanner, context);

			delete scanner;
			delete input;

			return value;
		}

		/**
		**	Parses data from the specified file and returns the final parsed object. A new parser and scanner will be
		**	automatically created and released by using this method.
		*/
		static void * parseFile (const char *filename, Context *context = NULL)
		{
			Parser *parser = new Parser ();

			void * value = parser->parse (filename, context);
			delete parser;

			return value;
		}
	};
};

#endif
